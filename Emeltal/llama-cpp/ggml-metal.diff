18a19
> #define GGML_METAL_BUFFER_OPTIONS MTLResourceStorageModeShared|MTLResourceHazardTrackingModeUntracked
22a24
> #define GGML_METAL_BUFFER_OPTIONS MTLResourceStorageModeShared
208,209d209
<     int n_cb;
< 
213,214d212
<     dispatch_queue_t d_queue;
< 
219,220d216
< 
<     bool should_capture_next_compute;
228,233d223
< // Here to assist with NSBundle Path Hack
< @interface GGMLMetalClass : NSObject
< @end
< @implementation GGMLMetalClass
< @end
< 
285a276,278
> static int g_backend_shared_context_ref_count = 0;
> struct ggml_metal_context *g_backend_shared_context = NULL;
> 
286a280,285
>     if(g_backend_shared_context) {
>         g_backend_shared_context_ref_count++;
>         GGML_METAL_LOG_INFO("%s: reusing existing context, now used by %d clients\n", __func__, g_backend_shared_context_ref_count);
>         return g_backend_shared_context;
>     }
> 
305d303
<     ctx->n_cb   = MIN(n_cb, GGML_METAL_MAX_BUFFERS);
307d304
<     ctx->d_queue = dispatch_queue_create("ggml-metal", DISPATCH_QUEUE_CONCURRENT);
312,316d308
<     //
<     // - first check if the library is embedded
<     // - then check if the library is in the bundle
<     // - if not found, load the source and compile it
<     // - if that fails, return NULL
318,398c310,319
<         NSBundle * bundle = nil;
< #ifdef SWIFT_PACKAGE
<         bundle = SWIFTPM_MODULE_BUNDLE;
< #else
<         bundle = [NSBundle bundleForClass:[GGMLMetalClass class]];
< #endif
< 
<         NSError * error = nil;
< 
< #if GGML_METAL_EMBED_LIBRARY
<         const bool try_metallib = false;
< #else
<         const bool try_metallib = true;
< #endif
< 
<         NSString * path_lib = [bundle pathForResource:@"default" ofType:@"metallib"];
<         if (try_metallib && path_lib != nil) {
<             // pre-compiled library found
<             NSURL * libURL = [NSURL fileURLWithPath:path_lib];
<             GGML_METAL_LOG_INFO("%s: loading '%s'\n", __func__, [path_lib UTF8String]);
< 
<             metal_library = [ctx->device newLibraryWithURL:libURL error:&error];
<             if (error) {
<                 GGML_METAL_LOG_ERROR("%s: error: %s\n", __func__, [[error description] UTF8String]);
<                 return NULL;
<             }
<         } else {
< #if GGML_METAL_EMBED_LIBRARY
<             GGML_METAL_LOG_INFO("%s: using embedded metal library\n", __func__);
< 
<             extern const char ggml_metallib_start[];
<             extern const char ggml_metallib_end[];
< 
<             NSString * src = [[NSString alloc] initWithBytes:ggml_metallib_start length:(ggml_metallib_end-ggml_metallib_start) encoding:NSUTF8StringEncoding];
< #else
<             GGML_METAL_LOG_INFO("%s: default.metallib not found, loading from source\n", __func__);
< 
<             NSString * path_source;
<             NSString * path_resource = [[NSProcessInfo processInfo].environment objectForKey:@"GGML_METAL_PATH_RESOURCES"];
< 
<             GGML_METAL_LOG_INFO("%s: GGML_METAL_PATH_RESOURCES = %s\n", __func__, path_resource ? [path_resource UTF8String] : "nil");
< 
<             if (path_resource) {
<                 path_source = [path_resource stringByAppendingPathComponent:@"ggml-metal.metal"];
<             } else {
<                 path_source = [bundle pathForResource:@"ggml-metal" ofType:@"metal"];
<             }
< 
<             if (path_source == nil) {
<                 GGML_METAL_LOG_WARN("%s: error: could not use bundle path to find ggml-metal.metal, falling back to trying cwd\n", __func__);
<                 path_source = @"ggml-metal.metal";
<             }
< 
<             GGML_METAL_LOG_INFO("%s: loading '%s'\n", __func__, [path_source UTF8String]);
< 
<             NSString * src = [NSString stringWithContentsOfFile:path_source encoding:NSUTF8StringEncoding error:&error];
<             if (error) {
<                 GGML_METAL_LOG_ERROR("%s: error: %s\n", __func__, [[error description] UTF8String]);
<                 return NULL;
<             }
< #endif // GGML_METAL_EMBED_LIBRARY
< 
<             @autoreleasepool {
<                 // dictionary of preprocessor macros
<                 NSMutableDictionary * prep = [NSMutableDictionary dictionary];
< 
< #ifdef GGML_QKK_64
<                 prep[@"GGML_QKK_64"] = @(1);
< #endif
< 
<                 MTLCompileOptions* options = [MTLCompileOptions new];
<                 options.preprocessorMacros = prep;
< 
<                 //[options setFastMathEnabled:false];
< 
<                 metal_library = [ctx->device newLibraryWithSource:src options:options error:&error];
<                 if (error) {
<                     GGML_METAL_LOG_ERROR("%s: error: %s\n", __func__, [[error description] UTF8String]);
<                     return NULL;
<                 }
<             }
---
>         NSBundle * bundle = [NSBundle mainBundle];
>         NSString * libPath = [bundle pathForResource:@"default" ofType:@"metallib"];
>         // pre-compiled library found
>         NSURL * libURL = [NSURL fileURLWithPath:libPath];
>         GGML_METAL_LOG_INFO("%s: loading '%s'\n", __func__, [libPath UTF8String]);
>         NSError *error;
>         metal_library = [ctx->device newLibraryWithURL:libURL error:&error];
>         if (error) {
>             GGML_METAL_LOG_ERROR("%s: error: %s\n", __func__, [[error description] UTF8String]);
>             return NULL;
441,442d361
< 
<     ctx->should_capture_next_compute = false;
659a579,582
> 
>     g_backend_shared_context_ref_count++;
>     g_backend_shared_context = ctx;
> 
663a587,592
>     g_backend_shared_context_ref_count--;
>     if(g_backend_shared_context_ref_count > 0) {
>         GGML_METAL_LOG_INFO("%s: removed a reference, still used by %d clients\n", __func__, g_backend_shared_context_ref_count);
>         return;
>     }
> 
664a594
>     g_backend_shared_context = nil;
673,674d602
<     dispatch_release(ctx->d_queue);
< 
831,853d758
<     // create multiple command buffers and enqueue them
<     // then, we encode the graph into the command buffers in parallel
< 
<     const int n_nodes  = gf->n_nodes;
<     const int n_cb = ctx->n_cb;
<     const int n_nodes_per_cb = (n_nodes + n_cb - 1) / n_cb;
< 
<     const bool should_capture = ctx->should_capture_next_compute;
<     if (should_capture) {
<         ctx->should_capture_next_compute = false;
< 
<         MTLCaptureDescriptor * descriptor = [MTLCaptureDescriptor new];
<         descriptor.captureObject = ctx->queue;
< 
<         NSError * error = nil;
<         if (![[MTLCaptureManager sharedCaptureManager] startCaptureWithDescriptor:descriptor error:&error]) {
<             GGML_METAL_LOG_ERROR("%s: error: unable to start capture '%s'\n", __func__, [[error localizedDescription] UTF8String]);
<             GGML_ASSERT(!"capture failed");
<         }
<     }
< 
<     id<MTLCommandBuffer> command_buffer_builder[n_cb];
<     for (int cb_idx = 0; cb_idx < n_cb; ++cb_idx) {
855,856d759
<         command_buffer_builder[cb_idx] = command_buffer;
< 
859,864d761
<     }
< 
<     const id<MTLCommandBuffer> *command_buffers = command_buffer_builder;
< 
<     dispatch_apply(n_cb, ctx->d_queue, ^(size_t iter) {
<         const int cb_idx = iter;
871d767
<         id<MTLCommandBuffer> command_buffer  = command_buffers[cb_idx];
874,882c770
<         const int node_start =                                      (cb_idx + 0) * n_nodes_per_cb;
<         const int node_end   = MIN((cb_idx == n_cb - 1) ? n_nodes : (cb_idx + 1) * n_nodes_per_cb, n_nodes);
< 
<         for (int i = node_start; i < node_end; ++i) {
<             if (i == -1) {
<                 [encoder memoryBarrierWithScope:MTLBarrierScopeBuffers];
<                 continue;
<             }
< 
---
>         for (int i = 0; i < gf->n_nodes; ++i) {
907a796
> #ifndef GGML_METAL_NDEBUG
912,915c801
< 
<             if (should_capture) {
<                 [encoder pushDebugGroup:[NSString stringWithCString:ggml_op_desc(dst) encoding:NSUTF8StringEncoding]];
<             }
---
> #endif
2759,2762d2644
< 
<             if (should_capture) {
<                 [encoder popDebugGroup];
<             }
2768d2649
<     });
2773,2774d2653
<     for (int i = 0; i < n_cb; ++i) {
<         id<MTLCommandBuffer> command_buffer = command_buffers[i];
2779,2784c2658
<             GGML_METAL_LOG_INFO("%s: command buffer %d failed with status %lu\n", __func__, i, status);
<             if (status == MTLCommandBufferStatusError) {
<                 NSString * error_code = [command_buffer error].localizedDescription;
<                 GGML_METAL_LOG_INFO("error: %s\n", [error_code UTF8String]);
<             }
< 
---
>             GGML_METAL_LOG_INFO("%s: command buffer failed with status %lu\n", __func__, status);
2788,2793d2661
< 
<     if (should_capture) {
<         [[MTLCaptureManager sharedCaptureManager] stopCapture];
<     }
< 
<     }
2954c2822
<                         options:MTLResourceStorageModeShared
---
>                         options:GGML_METAL_BUFFER_OPTIONS
3045c2913
<         ctx->buffers[ctx->n_buffers].metal = [device newBufferWithBytesNoCopy:data length:size_aligned options:MTLResourceStorageModeShared deallocator:nil];
---
>         ctx->buffers[ctx->n_buffers].metal = [device newBufferWithBytesNoCopy:data length:size_aligned options:GGML_METAL_BUFFER_OPTIONS deallocator:nil];
3068c2936
<             ctx->buffers[ctx->n_buffers].metal = [device newBufferWithBytesNoCopy:(void *) ((uint8_t *) data + i) length:size_step_aligned options:MTLResourceStorageModeShared deallocator:nil];
---
>             ctx->buffers[ctx->n_buffers].metal = [device newBufferWithBytesNoCopy:(void *) ((uint8_t *) data + i) length:size_step_aligned options:GGML_METAL_BUFFER_OPTIONS deallocator:nil];
3173,3174c3041
< void ggml_backend_metal_set_n_cb(ggml_backend_t backend, int n_cb) {
<     GGML_ASSERT(ggml_backend_is_metal(backend));
---
> void ggml_backend_metal_set_n_cb(ggml_backend_t backend, int n_cb) {}
3176,3180d3042
<     struct ggml_metal_context * ctx = (struct ggml_metal_context *)backend->context;
< 
<     ctx->n_cb = MIN(n_cb, GGML_METAL_MAX_BUFFERS);
< }
< 
3190,3193d3051
<     GGML_ASSERT(ggml_backend_is_metal(backend));
< 
<     struct ggml_metal_context * ctx = (struct ggml_metal_context *)backend->context;
<     ctx->should_capture_next_compute = true;
